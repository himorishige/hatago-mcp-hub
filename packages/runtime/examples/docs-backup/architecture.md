# Hatago アーキテクチャガイド

本ガイドでは、Hatago MCP Hubの内部アーキテクチャについて説明します。マルチランタイム対応のためのプラットフォーム抽象化レイヤーと軽量実装アプローチを含みます。

## 概要

Hatagoは3つの主要な原則に基づいて構築されています：

1. **プラットフォーム抽象化** - Node.js、Cloudflare Workers、および将来のランタイムに対応するランタイム非依存設計
2. **軽量コア** - 最小限の依存関係とオプショナルなエンタープライズ機能
3. **プロキシアーキテクチャ** - ケイパビリティグラフによる複数MCPサーバーの統合管理

## レイヤードアーキテクチャ

```
┌─────────────────────────────────────────────────────────────┐
│                   アプリケーションレイヤー                    │
│          (Hono HTTPサーバー / CLI / API)                     │
├─────────────────────────────────────────────────────────────┤
│                      コアレイヤー                            │
│     (McpHub、レジストリ、セッションマネージャー、管理機能)      │
├─────────────────────────────────────────────────────────────┤
│              プラットフォーム抽象化レイヤー                    │
│               (プラットフォームインターフェース)               │
├─────────────────────────────────────────────────────────────┤
│            ランタイム実装レイヤー                            │
│        (Node.js / Workers / Deno / Bun)                    │
└─────────────────────────────────────────────────────────────┘
```

## プラットフォーム抽象化

プラットフォーム抽象化レイヤーにより、Hatagoは統一されたインターフェースを通じて複数のJavaScriptランタイムで動作可能です：

### コアプラットフォームインターフェース

```typescript
interface Platform {
  capabilities: RuntimeCapabilities;
  storage: Storage; // ファイルまたはKVストレージ
  events: EventBus; // イベントエミッター抽象化
  transport: MCPTransport; // MCP通信
  logger: Logger; // ロギング抽象化
  crypto: Crypto; // 暗号化操作
  process: ProcessRunner; // 子プロセス管理
}
```

### ランタイムケイパビリティ

| ランタイム | ファイルシステム | 子プロセス | TCPソケット | MCP種別            |
| ---------- | ---------------- | ---------- | ----------- | ------------------ |
| Node.js    | ✅               | ✅         | ✅          | local, npx, remote |
| Workers    | ❌               | ❌         | ❌          | remoteのみ         |
| Deno       | ✅               | ✅         | ✅          | local, npx, remote |
| Bun        | ✅               | ✅         | ✅          | local, npx, remote |

### 実装状況

- **✅ Node.js**: 全サーバータイプに対応した完全実装
- **✅ Cloudflare Workers**: KVストレージを使用したリモートサーバー
- **🚧 Deno**: Node.js実装を使用（ネイティブ対応予定）
- **🚧 Bun**: Node.js実装を使用（最適化予定）

## コアアーキテクチャ（Lite版）

Lite版は最小限の依存関係で必須のMCP Hub機能に焦点を当てています：

### 必須コンポーネント

```
src/
├── core/              # コアMCP Hub機能
│   ├── mcp-hub.ts           # メインハブオーケストレーター（約500行）
│   ├── mcp-hub-tools.ts     # ツール管理（分離済み）
│   ├── mcp-hub-resources.ts # リソース管理（分離済み）
│   ├── mcp-hub-prompts.ts   # プロンプト管理（分離済み）
│   ├── session-manager.ts   # セッション分離
│   ├── tool-registry.ts     # ツールレジストリ
│   ├── resource-registry.ts # リソースレジストリ
│   ├── prompt-registry.ts   # プロンプトレジストリ
│   └── config-manager.ts    # 設定管理
├── platform/          # プラットフォーム抽象化レイヤー
│   ├── types.ts             # プラットフォームインターフェース
│   ├── detector.ts          # ランタイム検出
│   ├── node/               # Node.js実装
│   └── workers/            # Cloudflare Workers実装
├── servers/           # MCPサーバー実装
│   ├── server-registry.ts   # サーバーライフサイクル管理
│   ├── npx-mcp-server.ts   # NPXパッケージ実行
│   ├── remote-mcp-server.ts # リモートサーバー接続
│   └── custom-stdio-transport.ts # STDIOトランスポート
├── transport/         # 通信レイヤー
│   ├── stdio.ts            # STDIOトランスポート
│   └── http.ts             # HTTP/SSEトランスポート
├── storage/           # データ永続化
│   ├── unified-file-storage.ts   # ファイルベースストレージ
│   └── memory-registry-storage.ts # インメモリストレージ
├── cli/               # コマンドラインインターフェース
│   ├── index.ts            # CLIエントリーポイント
│   └── commands/           # 個別コマンド
└── utils/             # ユーティリティ
    ├── logger.ts           # シンプルロギング
    ├── errors.ts           # エラーハンドリング
    └── mutex.ts            # 並行制御
```

### コア機能

- **MCP Hubサーバー**: 複数MCPサーバーの統合管理
- **セッション管理**: mcp-session-idヘッダーによる分離
- **衝突回避**: ツール名の自動プレフィックス付与
- **マルチトランスポート**: STDIO（デフォルト）とHTTP/SSEサポート
- **マルチサーバー**: NPX、リモート、ローカルサーバーサポート
- **ホットリロード**: 再起動なしでの設定変更
- **シンプルロギング**: 重いフレームワークを使用しないコンソールベース

## ケイパビリティグラフ＆プロキシパターン

Hatagoは、サーバーを独立したユニットとして扱うのではなく、ケイパビリティグラフを使用します：

### ケイパビリティグラフ

```
┌─────────────────────────────────────────────────────────────┐
│                    ケイパビリティグラフ                       │
│  ┌─────────┐      ┌─────────┐      ┌─────────────────────┐ │
│  │ サーバー1 │──────│ サーバー2 │──────│     サーバー3        │ │
│  │ ツール:3  │      │ ツール:5  │      │     ツール:2         │ │
│  │ リソース:2 │      │ リソース:4 │      │     プロンプト:1     │ │
│  └─────────┘      └─────────┘      └─────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                     プロキシレイヤー                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │
│  │ツールマネージャ│  │リソースMgr   │  │プロンプトマネージャ   │ │
│  │ 10ツール     │  │ 6リソース    │  │  1プロンプト        │ │
│  └─────────────┘  └─────────────┘  └─────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 利点

- **統一インターフェース**: 全サーバーケイパビリティのための単一API
- **インテリジェントルーティング**: 適切なサーバーへの自動リクエストルーティング
- **衝突検出**: 名前の衝突を防ぐ自動プレフィックス付与
- **ホットスワッピング**: 他に影響を与えずにサーバーを追加/削除

## データフロー

### ツール呼び出しフロー

```
1. クライアントリクエスト (STDIO/HTTP)
   ↓
2. トランスポートレイヤー
   ↓
3. プラットフォーム抽象化 (ランタイム固有の処理)
   ↓
4. セッションマネージャー (分離)
   ↓
5. ツールマネージャー (衝突回避付きルーティング)
   ↓
6. サーバーレジストリ (サーバー選択)
   ↓
7. サーバーノード (実行)
   ↓
8. レスポンス (逆フロー)
```

### プラットフォーム検出と初期化

```typescript
// 自動ランタイム検出とプラットフォーム作成
const platform = detectAndCreatePlatform({
  storage: { type: 'file', path: './.hatago' },
  logger: { level: 'info' }
});

// プラットフォームでハブを初期化
const hub = new McpHub(platform);
```

## 将来の拡張計画

将来的には、以下のようなエンタープライズ機能を条件付きで追加できる設計になっています：

### 計画中の機能

- **ヘルスチェック**: サーバーの健全性モニタリング
- **メトリクス**: Prometheus形式のメトリクス収集
- **分散トレーシング**: リクエストの追跡
- **認証機能**: JWT/OAuth対応
- **レート制限**: API利用制限
- **サーキットブレーカー**: 障害時の自動遮断

これらの機能は、コアを軽量に保つため、必要に応じてプラグイン形式で追加される予定です。

## サーバータイプ

### ローカルサーバー

- **実行**: 任意のコマンドによる子プロセス
- **トランスポート**: STDIO
- **ユースケース**: 任意の言語のカスタムMCPサーバー

### NPXサーバー

- **実行**: npx経由のnpmパッケージ
- **トランスポート**: STDIO
- **ユースケース**: 公開されたMCPパッケージ

### リモートサーバー

- **実行**: ネットワーク接続
- **トランスポート**: HTTP/SSE
- **ユースケース**: クラウドホストのMCPサービス

## 設計原則

1. **プラットフォーム非依存**: ランタイムに依存しないコアロジック
2. **軽量コア**: 最小限の依存関係、オプショナルな機能
3. **継承より合成**: モジュラー、合成可能なコンポーネント
4. **フェイルセーフデフォルト**: 最小限の設定で動作
5. **段階的な拡張**: 必要に応じて複雑性を追加
6. **セッション分離**: 各クライアントが独立した状態を持つ

## パフォーマンス特性

### 軽量設計による効果

- **高速起動**: 最小限の依存関係により素早い起動を実現
- **低メモリフットプリント**: 効率的なリソース管理
- **コンパクトなバンドルサイズ**: 必要最小限のコードベース
- **シンプルな依存関係**: Hono、MCP SDK、Zod、Commanderのみ

### 最適化戦略

- HTTPクライアントの接続プーリング
- プラットフォーム固有機能の動的読み込み
- 効率的なセッション管理
- 最小限の抽象化オーバーヘッド

## 拡張ポイント

### 新しいランタイムの追加

1. `Platform`インターフェースを実装
2. ランタイム検出ロジックを追加
3. ランタイム固有の実装を作成
4. プラットフォーム検出器に登録

### 新しいサーバータイプの追加

1. `ServerNode`基底クラスを拡張
2. 必要なトランスポートを実装
3. `ServerRegistry`に登録
4. 設定スキーマを追加

### 拡張機能の追加

1. 新機能のモジュールを作成
2. プラットフォーム層への統合
3. 設定オプションの追加
4. ドキュメントの更新

このアーキテクチャは、シンプルさとパフォーマンスを維持しながら、最小限のデプロイメントからエンタープライズインストールまでスケール可能な、軽量でマルチランタイム対応のMCP Hubのための堅固な基盤を提供します。
